# Python Pro. Занятие 4

_Человек отличается от низших приматов страстью к составлению списков._

- Гарри Аллен Смит

Мы говорили о базовых типах данных Python, таких как:

- bool
- int
- float
- str

Если представлять их как атомы, то структуры данных, которые мы рассмотрим, можно назвать молекулами. Так и есть: мы объединим базовые типы в более сложные структуры

## Кортежи

Начнем с создания пустого кортежа с помощью оператора ():

```python
empty_tuple = ()
print(empty_tuple) # ()
```

Чтобы создать кортеж, содержащий один элемент и более, после каждого элемента надо ставить запятую.

Это вариант для кортежей с одним элементом:

```python
one_marx = 'Groucho',
print(one_marx) # ('Groucho',)
```

Вы можете поместить элемент в круглые скобки и получить такой же кортеж:

```python
one_marx = ('Groucho',)
```

> Однако следует иметь в виду: если в круглые скобки вы поместите один объект и опустите при этом запятую, в результате вы получите не кортеж, а тот же самый объект:

```python
one_marx = ('Groucho')
print(type(one_marx)) # <class 'str'>
```

Если в вашем кортеже более одного элемента, ставьте запятую после каждого из них, кроме последнего:

```python
marx_tuple = 'Groucho', 'Chico', 'Harpo'
print(marx_tuple) # ('Groucho', 'Chico', 'Harpo')
```

Кортежи позволяют присваивать значение нескольким переменным одновременно:

```python
marx_tuple = ('Groucho', 'Chico', 'Harpo')
a, b, c = marx_tuple
print(a) # 'Groucho'
print(b) # 'Chico'
print(c) # 'Harpo'
```

Это называется _распаковкой кортежа_.

## Создаем кортежи с помощью функции tuple()

Функция преобразования `tuple()` создает кортежи из других объектов:

```python
marx_list = ['Groucho', 'Chico', 'Harpo']
print(tuple(marx_list)) # ('Groucho', 'Chico', 'Harpo')
```

## Объединяем кортежи с помощью оператора +

Это похоже на объединение строк:

```python
print(('Groucho',) + ('Chico', 'Harpo')) # ('Groucho', 'Chico', 'Harpo')
```

## Размножаем элементы с помощью оператора \*

Принцип похож на многократное использование оператора +:

```python
print(('yada',) * 3) # ('yada', 'yada', 'yada')
```

## Сравниваем кортежи

Сравнение кортежей похоже на сравнение списков:

```python
a = (7, 2)
b = (7, 2, 9)
print(a == b) # False
print(a <= b) # True
pint(a < b) # True
```

## Итерируем по кортежам с помощью for и in

Итерирование по кортежам выполняется так же, как и итерирование по другим типам:

```python
words = ('fresh','out', 'of', 'ideas')
for word in words:
     print(word)

# fresh
# out
# of
# deas
```

## Изменяем кортеж

Этого сделать вы не можете! Как и строки, кортежи неизменяемы. Но ранее вы уже видели на примере строк, что можно сконкатенировать (объединить) кортежи и создать таким образом новый кортеж:

```python
t1 = ('Fee', 'Fie', 'Foe')
t2 = ('Flop',)
print(t1 + t2) # ('Fee', 'Fie', 'Foe', 'Flop')
```

Это означает, что вы можете изменить кортеж следующим образом:

```python
t1 = ('Fee', 'Fie', 'Foe')
t2 = ('Flop',)
t1 += t2
print(t1) # ('Fee', 'Fie', 'Foe', 'Flop')
```

Это уже не тот же самый кортеж t1. Python создал новый кортеж из исходных t1 и t2 и присвоил ему имя t1.

С помощью `id()` вы можете увидеть, когда имя переменной будет указывать на новое значение:

```python
t1 = ('Fee', 'Fie', 'Foe')
t2 = ('Flop',)
print(id(t1)) # 4365405712

t1 += t2
print(id(t1)) # 4364770744
```

# Списки

Списки особенно удобны для хранения в них объектов в определенном порядке, особенно если порядок или содержимое нужно будет изменить. В отличие от строк список изменяем: вы можете добавить новые элементы, перезаписать существующие и удалить ненужные.

## Создаем списки с помощью скобок []

Список можно создать из нуля и более элементов, разделенных запятыми и заключенных в квадратные скобки:

```python
empty_list = [ ]
weekdays = ['Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday']
big_birds = ['emu', 'ostrich', 'cassowary']
first_names = ['Graham', 'John', 'Terry', 'Terry', 'Michael']
leap_years = [2000, 2004, 2008]
randomness = ['Punxsatawney", {"groundhog": "Phil"}, "Feb. 2"}
```

Список `first_names` показывает, что значения не должны быть уникальными.

Если вы хотите размещать в последовательности только уникальные значения и вам неважен их порядок, _множество_ (set) может оказаться более удобным вариантом, чем список. В предыдущем примере список big_birds вполне мог быть множеством. О множествах мы поговорим позже.

## Создаем список или преобразуем в список с помощью функции list()

Вы также можете создать пустой список с помощью функции list():

```python
another_empty_list = list()
```

Функция list() преобразует другие итерабельные типы данных (например, кортежи, строки, множества и словари) в списки. В следующем примере строка преобразуется в список, состоящий из односимвольных строк:

```python
print(list('cat')) # ['c', 'a', 't']
```

В этом примере кортеж преобразуется в список:

```python
a_tuple = ('ready', 'fire', 'aim')
print(list(a_tuple)) # ['ready', 'fire', 'aim']
```

## Создаем список из строки с использованием функции split()

Как я упоминал в разделе «Разделяем строку с помощью функции split()» главы 5, функцию split() можно использовать для преобразования строки в список, указав некую строку-разделитель:

```python
talk_like_a_pirate_day = '9/19/2019'
print9talk_like_a_pirate_day.split('/')) # ['9', '19', '2019']
```

Что, если в оригинальной строке содержится несколько включений строки-разделителя подряд? В этом случае в качестве элемента списка вы получите пустую строку:

```python
splitme = 'a/b//c/d///e'
print(splitme.split('/')) # ['a', 'b', '', 'c', 'd', '', '', 'e']
```

> Если бы вы использовали разделитель //, состоящий из двух символов, то получили бы следующий результат:

```python
splitme = 'a/b//c/d///e'
splitme.split('//') # ['a/b', 'c/d', '/e']
```

## Получаем элемент с помощью конструкции [index]

Как и в случае со строками, вы можете извлечь одно значение из списка, указав его индекс:

```python
marxes = ['Groucho', 'Chico', 'Harpo']
print(marxes[0]) # 'Groucho'
print(marxes[1]) # 'Chico'
print(marxes[2]) # 'Harpo'
```

Так же и отрицательные индексы отсчитываются с конца строки:

```python
print(marxes[-1]) # 'Harpo'
print(marxes[-2] # 'Chico'
print(marxes[-3]) # 'Groucho'
```

## Извлекаем элементы с помощью разделения

Можно извлечь из списка подсписок, использовав разделение (slice):

```python
marxes = ['Groucho', 'Chico,' 'Harpo']
print(marxes[0:2]) # ['Groucho', 'Chico']
```

Такой фрагмент списка тоже является списком.

При разделении можно пропускать некоторые значения. В следующем примере мы извлечем каждый нечетный элемент:

```python
print(marxes[::2]) # ['Groucho', 'Harpo']
```

И наконец, рассмотрим прием резворота списка:

```python
print(marxes[::-1]) # ['Harpo', 'Chico', 'Groucho']

```

Ни одно из этих разделений не затронуло сам список marxes, поскольку мы не выполняли присваивание. Чтобы изменить порядок элементов в списке, используйте функцию `list.reverse()`:

```python
marxes = ['Groucho', 'Chico', 'Harpo']
marxes.reverse()
print(marxes) # ['Harpo', 'Chico', 'Groucho']
```

## Добавляем элемент в конец списка с помощью функции append()

Традиционный способ добавления элементов в список — вызов метода `append()`, который один за одним добавит их в конец списка. В предыдущих примерах мы забыли о _Zeppo_, но ничего страшного не случилось, поскольку список можно изменить. Добавим его прямо сейчас:

```python
marxes = ['Groucho', 'Chico', 'Harpo']
marxes.append('Zeppo')
print(marxes) # ['Groucho', 'Chico', 'Harpo', 'Zeppo']
```

## Добавляем элемент на определенное место с помощью функции insert()

Функция `append()` добавляет элементы только в конец списка. Когда вам нужно добавить элемент и поставить его на заданную позицию, используйте функцию `insert()`. Если вы укажете индекс 0, элемент будет добавлен в начало списка. Если значение смещения выходит за пределы списка, элемент будет добавлен в конец, как делает и функция `append()`: таким образом, вам не нужно беспокоиться о том, что Python выдаст ошибку:

```python
marxes = ['Groucho', 'Chico', 'Harpo']
marxes.insert(2, 'Gummo')
print(marxes) # ['Groucho', 'Chico', 'Harpo', 'Gummo']
marxes.insert(10, 'Zeppo')
print(marxes) # ['Groucho', 'Chico', 'Harpo', 'Gummo', 'Zeppo']
```

## Размножаем элементы с помощью оператора \*

В главе 5 вы видели, что можно размножить символы строки с помощью оператора \*. Точно так же можно сделать и со списками:

```python
print(["blah"] * 3) # ['blah', 'blah', 'blah']
```

## Объединяем списки с помощью метода extend() или оператора +

Можно объединить один список с другим, используя `extend()`. Предположим, что некий добрый человек дал нам новый список братьев Маркс, который называется others, и мы хотим добавить его в основной список marxes:

```python
marxes = ['Groucho', 'Chico', 'Harpo', 'Zeppo']
others = ['Gummo', 'Karl']
marxes.extend(others)
marxes # ['Groucho', 'Chico', 'Harpo', 'Zeppo', 'Gummo', 'Karl']
```

Можно также использовать операторы + или +=:

```python
marxes = ['Groucho', 'Chico', 'Harpo', 'Zeppo']
others = ['Gummo', 'Karl']
marxes += others
print(marxes) # ['Groucho', 'Chico', 'Harpo', 'Zeppo', 'Gummo', 'Karl']
```

> Если бы мы использовали `append()`, список others был бы добавлен как один из элементов списка, а не дополнил бы своими элементами список marxes:

```python
marxes = ['Groucho', 'Chico', 'Harpo', 'Zeppo']
others = ['Gummo', 'Karl']
marxes.append(others)
print(marxes) # ['Groucho', 'Chico', 'Harpo', 'Zeppo', ['Gummo', 'Karl']]
```

Это еще раз показывает, что список может содержать элементы **разных типов**. В этом случае — четыре строки и список из двух строк.

## Изменяем элемент с помощью конструкции [index]

Так же как значение какого-либо элемента из списка можно получить по индексу, его можно и изменить:

```python
marxes = ['Groucho', 'Chico', 'Harpo']
marxes[2] = 'Wanda'
python(marxes) # ['Groucho', 'Chico', 'Wanda']
```

## Изменяем элементы с помощью разделения

В предыдущем разделе вы увидели, как получить подсписок с помощью разделе­ния. Помимо этого, с помощью разделения можно присвоить значения под­списку:

```python
numbers = [1, 2, 3, 4]
numbers[1:3] = [8, 9]
python(numbers) # [1, 8, 9, 4]
```

То, что находится справа от = и что вы присваиваете списку, может содержать иное количество элементов, нежели список, указанный слева:

```python
numbers = [1, 2, 3, 4]
numbers[1:3] = [7, 8, 9]
print(numbers) # [1, 7, 8, 9, 4]

 
numbers = [1, 2, 3, 4]
numbers[1:3] = []
print(numbers) # [1, 4]
```

На самом деле то, что находится справа от оператора присваивания, может даже не быть списком. Подойдет любой итерабельный объект, элементы которого можно сделать элементами списка:

```python
numbers = [1, 2, 3, 4]
numbers[1:3] = (98, 99, 100)
python(numbers) # [1, 98, 99, 100, 4]

 
numbers = [1, 2, 3, 4]
numbers[1:3] = 'wat?'
python(numbers) # [1, 'w', 'a', 't', '?', 4]
```

## Удаляем элемент по значению с помощью функции remove()

Если вы не знаете точно или вам все равно, в какой позиции находится элемент, используйте функцию `remove()`, чтобы удалить его по значению. Прощай, Groucho:

```python
marxes = ['Groucho', 'Chico', 'Harpo']
marxes.remove('Groucho')
print(marxes) # ['Chico', 'Harpo']

```

Если у вас были повторяющиеся элементы списка с одинаковым значением, функция `remove()` удалит только первый найденный элемент.

## Получаем и удаляем заданный элемент с помощью функции pop()

Получить элемент из списка и так же удалить его можно с помощью функции `pop()`. Если вызвать функцию `pop()` и указать инндекс, она возвратит элемент, находящийся в заданной позиции. Если аргумент не указать, будет использовано значение –1. Так, вызов `pop(0)` вернет начальный элемент списка, а вызов `pop()` или `pop(−1)` — конечный, как показано далее:

```python
marxes = ['Groucho', 'Chico', 'Harpo', 'Zeppo']

print(marxes.pop()) # 'Zeppo'
print(marxes) # ['Groucho', 'Chico', 'Harpo']

print (marxes.pop(1)) # 'Chico'
print(marxes) # ['Groucho', 'Harpo']
```

## Определяем смещение по значению с помощью функции index()

Если вы хотите узнать смещение элемента в списке по его значению, используйте функцию index():

```python
>>> marxes = ['Groucho', 'Chico', 'Harpo', 'Zeppo']
>>> print(marxes.index('Chico')) # 1
```

> Если значение встречается в списке более одного раза, возвращается смещение только первого найденного элемента

## Проверяем на наличие элемента в списке с помощью оператора in

В Python наличие элемента в списке проверяется с помощью оператора `in`:

```python
marxes = ['Groucho', 'Chico', 'Harpo', 'Zeppo']
print('Groucho' in marxes) # True
print('Bob' in marxes) # False
```

## Преобразуем список в строку с помощью функции join()

В разделе «Объединяем строки с помощью функции join()» главы 5 функция join() рассматривается более подробно, но вот еще один пример того, что можно сделать с ее помощью:

```python
marxes = ['Groucho', 'Chico', 'Harpo']
print(', '.join(marxes)) # 'Groucho, Chico, Harpo'

```

На первый взгляд это выглядит неправильным. Функция `join()` предназначается для строк, а не для списков. Вы не можете написать `marxes.join(',')`, даже если интуиция вам так подсказывает. Аргументом для функции `join()` является строка или любая итерабельная последовательность строк (в том числе и список), а выводом — строка. Если бы функция `join()` была только методом списка, ее нельзя было бы использовать для других итерабельных объектов, таких как кортежи и строки. Если вы хотите, чтобы она работала с любым итерабельным типом, нужно написать особый код для каждого типа и таким образом обработать подобное объединение. Это поможет вам запомнить: `join()` противоположна `split()`, как показано здесь:

```python
friends = ['Harry', 'Hermione', 'Ron']
separator = ' * '
joined = separator.join(friends)
print(joined) # 'Harry * Hermione * Ron'

separated = joined.split(separator)
print(separated) # ['Harry', 'Hermione', 'Ron']

print(separated == friends) # True

```

## Меняем порядок элементов с помощью функций sort() или sorted()

Часто вам будет нужно сортировать элементы в списке по значению, а не по индексу. Для этого Python предоставляет две функции:

- функцию списка sort(), которая сортирует сам список;
- общую функцию sorted(), которая возвращает отсортированную копию списка.

Если элементы списка являются числами, они по умолчанию сортируются по возрастанию. Если строками — сортируются в алфавитном порядке:

```python
marxes = ['Groucho', 'Chico', 'Harpo']
sorted_marxes = sorted(marxes)
print(sorted_marxes) # ['Chico', 'Groucho', 'Harpo']
```

`sorted_marxes` — это копия, ее создание не изменило оригинальный список:

```python
print(marxes) # ['Groucho', 'Chico', 'Harpo']
```

Но вызов функции списка `sort()` изменит marxes:

```python
marxes.sort()
print(marxes) # ['Chico', 'Groucho', 'Harpo']
```

Если все элементы списка одного типа (в списке marxes находятся только строки), функция sort() отработает корректно. Иногда можно даже смешать типы, например, целые числа и числа с плавающей точкой, поскольку они автоматически преобразуются друг в друга:

```python
numbers = [2, 1, 4.0, 3]
numbers.sort()
python(numbers) # [1, 2, 3, 4.0]
```

По умолчанию список сортируется по возрастанию, но можно добавить аргумент `reverse=True`, чтобы отсортировать список по убыванию:

```python
numbers = [2, 1, 4.0, 3]
numbers.sort(reverse=True)
print(numbers) # [4.0, 3, 2, 1]
```

Получаем длину списка с помощью функции len()
Функция len() возвращает количество элементов списка:

```python
marxes = ['Groucho', 'Chico', 'Harpo']
print(len(marxes)) # 3
```

## Копируем списки с помощью функций copy() и list() или путем разделения

Вы можете скопировать значения в отдельный новый список с помощью любого из этих методов:

- функции copy()
- функции преобразования list()
- разделения списка [:]

Оригинальный список снова будет присвоен переменной а. Мы создадим b с помощью функции списка copy(), c — с помощью функции преобразования list(), а d — с помощью разделения списка:

```python
a = [1, 2, 3]
b = a.copy()
c = list(a)
d = a[:]
```

Опять же b, c и d являются копиями — новыми объектами со своими собственными значениями и не связанными с исходным списком объектов [1,2,3], на который ссылается a. Изменение не влияет на копии b, c и d:

```python
a[0] = 'integer lists are boring'
print(a) # ['integer lists are boring', 2, 3]

print(b) # [1, 2, 3]
print(c) # [1, 2, 3]
print(d) # [1, 2, 3]
```

## Копируем все с помощью функции deepcopy()

Функция `copy()` хорошо работает, если все элементы списка являются **неизменяемыми**. Как вы видели ранее, изменяемые значения (например, списки, кортежи или словари) являются ссылками. Изменение оригинала или копии отразится на каждом из них.

Воспользуемся предыдущим примером, но в качестве последнего элемента списка a вместо целого числа 3 используем список [8,9]:

```python
a = [1, 2, [8, 9]]

b = a.copy()
c = list(a)
d = a[:]

print(a) # [1, 2, [8, 9]]
print(b) # [1, 2, [8, 9]]
print(c) # [1, 2, [8, 9]]
print(d) # [1, 2, [8, 9]]
```

Пока все хорошо. Теперь изменим элемент нашего подсписка из списка а:

```python
>>> a[2][1] = 10

print(a) # [1, 2, [8, 10]]
print(b) # [1, 2, [8, 10]]
print(c) # [1, 2, [8, 10]]
print(d) # [1, 2, [8, 10]]
```

Значение элемента a[2] теперь является списком, и его элементы могут быть изменены. Все методы копирования списков, которые мы уже рассмотрели, были поверхностными: это не оценочное суждение — речь идет именно о том, насколько глубоко распространяется копирование.

Для того чтобы это исправить, нужно использовать функцию `deepcopy()`:

```python
import copy

a = [1, 2, [8, 9]]

b = copy.deepcopy(a)

print(a) # [1, 2, [8, 9]]
print(b) # [1, 2, [8, 9]]

a[2][1] = 10

print(a) # [1, 2, [8, 10]]
print(b) # [1, 2, [8, 9]]
```

Функция `deepcopy()` может работать с вложенными списками, словарями и другими объектами.

## Итерируем по спискам с помощью операторов for и in

Часто нужно проводить итерациии по списку

```python
cheeses = ['brie', 'gjetost', 'havarti']
for cheese in cheeses:
     print(cheese)

# brie
# gjetost
# havarti
```

## Конструкторы списков
Это способ создать список компактно и понятно, вместо того чтобы писать цикл for и добавлять элементы вручную через append

**Общий синтаксис:**
```python
[выражение for элемент in итерируемый_объект if условие]
```
выражение — что мы хотим положить в новый список (может быть сам элемент или результат вычисления).
for элемент in … — цикл по исходной коллекции.
if условие — (опционально) фильтрация элементов.

```python
arr = [1, 2, 3, 4, 5]
squares = [x**2 for x in arr]
print(squares)  # [1, 4, 9, 16, 25]
```

Итерации по нескольким параметрам
```python
bank = [['Степа', 200], ['Коля', 300], ['Света', 500]]
total = sum(amount for _, amount in bank)
print(total)  # 1000
```

Фильтрация списка
```python
arr = [1,2,3,4,5]
odd = [x for x in arr if x % 2 == 0]
print(odd) # [2, 4]
```
